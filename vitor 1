import pandas as pd
import numpy as np
import openpyxl
from openpyxl.utils.dataframe import dataframe_to_rows
from datetime import datetime
import os
import sys
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import traceback

def process_xav_data(input_file, output_file=None, status_callback=None, selected_periods=None):
    """
    Process XAV Excel file and update the FUTURE sheet.
    
    Args:
        input_file (str): Path to the input Excel file
        output_file (str, optional): Path to save the output Excel file. 
                                    If None, will modify the input file name.
        status_callback (function, optional): Callback function to update status
        selected_periods (list, optional): List of periods to process. If None, process all.
    
    Returns:
        str: Path to the output file
    """
    def update_status(message):
        if status_callback:
            status_callback(message)
        else:
            print(message)
    
    if output_file is None:
        file_name, file_ext = os.path.splitext(input_file)
        output_file = f"{file_name} - Processed{file_ext}"
    
    update_status(f"Processing {input_file}...")
    
    # Load the Excel workbook
    workbook = openpyxl.load_workbook(input_file)
    
    # Check for required sheets
    required_sheets = ["XAV Extract", "Account Mapping", "Reference Mapping", "FUTURE"]
    missing_sheets = [sheet for sheet in required_sheets if sheet not in workbook.sheetnames]
    
    if missing_sheets:
        raise ValueError(f"Missing required sheets: {', '.join(missing_sheets)}")
    
    # STEP 1: Extract data from the required sheets
    update_status("Extracting data from required sheets...")
    
    # Get XAV Extract data
    xav_sheet = workbook["XAV Extract"]
    
    # Find headers in XAV Extract
    period_col = None
    account_col = None
    cc_col = None
    amount_col = None
    
    # Scan the first row to find column headers
    for cell in xav_sheet[1]:
        if cell.value == "Period":
            period_col = cell.column_letter
        elif cell.value == "Nat Account":
            account_col = cell.column_letter
        elif cell.value == "CC":
            cc_col = cell.column_letter
        elif cell.value == "Amount":
            amount_col = cell.column_letter
    
    if not all([period_col, account_col, cc_col, amount_col]):
        raise ValueError("Could not find all required columns in XAV Extract sheet")
    
    update_status(f"Found XAV Extract columns: Period={period_col}, Nat Account={account_col}, CC={cc_col}, Amount={amount_col}")
    
    # Read XAV data
    xav_data = []
    row_num = 2  # Start from row 2 (after header)
    while True:
        period = xav_sheet[f"{period_col}{row_num}"].value
        account = xav_sheet[f"{account_col}{row_num}"].value
        cc = xav_sheet[f"{cc_col}{row_num}"].value
        amount = xav_sheet[f"{amount_col}{row_num}"].value
        
        # Stop when we hit a blank row
        if period is None and account is None and cc is None and amount is None:
            break
        
        if period and account and cc and amount:
            xav_data.append({
                "Period": period,
                "Nat Account": str(account),
                "CC": str(cc),
                "Amount": float(amount)
            })
        
        row_num += 1
    
    update_status(f"Read {len(xav_data)} rows from XAV Extract")
    
    # Get Account Mapping data
    account_sheet = workbook["Account Mapping"]
    
    # Find headers in Account Mapping
    account_col = None
    report_col = None
    
    for cell in account_sheet[1]:
        if cell.value == "Account":
            account_col = cell.column_letter
        elif cell.value == "REPORT 2":
            report_col = cell.column_letter
    
    if not all([account_col, report_col]):
        raise ValueError("Could not find all required columns in Account Mapping sheet")
    
    update_status(f"Found Account Mapping columns: Account={account_col}, REPORT 2={report_col}")
    
    # Read Account Mapping
    account_to_tag = {}
    row_num = 2  # Start from row 2 (after header)
    while True:
        account = account_sheet[f"{account_col}{row_num}"].value
        tag = account_sheet[f"{report_col}{row_num}"].value
        
        # Stop when we hit a blank row
        if account is None:
            break
        
        if account and tag:
            account_to_tag[str(account)] = tag
        
        row_num += 1
    
    update_status(f"Found {len(account_to_tag)} account to tag mappings")
    
    # Get Reference Mapping data for period to month
    ref_sheet = workbook["Reference Mapping"]
    
    # Find headers in Reference Mapping - note: the sheet structure is offset, starting at row 2
    actual_month_col = None
    xav_month_col = None
    
    # Check row 2 for headers
    for cell in ref_sheet[2]:
        if cell.value == "Actual Month":
            actual_month_col = cell.column_letter
        elif cell.value == "Current XAV Month":
            xav_month_col = cell.column_letter
    
    if not all([actual_month_col, xav_month_col]):
        raise ValueError("Could not find all required columns in Reference Mapping sheet")
    
    update_status(f"Found Reference Mapping columns: Actual Month={actual_month_col}, Current XAV Month={xav_month_col}")
    
    # Read period to month mapping
    period_to_month = {}
    row_num = 3  # Start from row 3 (after header)
    while True:
        actual_month = ref_sheet[f"{actual_month_col}{row_num}"].value
        xav_month = ref_sheet[f"{xav_month_col}{row_num}"].value
        
        # Stop when we hit a blank row
        if actual_month is None and xav_month is None:
            break
        
        if actual_month and xav_month:
            period_to_month[xav_month] = actual_month
        
        row_num += 1
    
    update_status(f"Found {len(period_to_month)} period to month mappings")
    
    # Find Report to Future Tag mapping
    # The structure shows this is in Reference Mapping around row 16
    mapping_found = False
    tag_to_future_tag = {}
    
    # Scan the entire Reference Mapping sheet for the section
    for row_num in range(1, ref_sheet.max_row + 1):
        # Look for the "Account Mapping" and "FUTURE" headers
        cell_account = ref_sheet.cell(row=row_num, column=3).value
        cell_future = ref_sheet.cell(row=row_num, column=4).value
        
        if cell_account == "Account Mapping" and cell_future == "FUTURE":
            mapping_found = True
            # Start reading from the next row
            row_num += 1
            
            # Read mappings until blank row
            while row_num <= ref_sheet.max_row:
                tag = ref_sheet.cell(row=row_num, column=3).value
                future_tag = ref_sheet.cell(row=row_num, column=4).value
                
                if tag is None or future_tag is None:
                    break
                
                tag_to_future_tag[tag] = future_tag
                row_num += 1
            
            break
    
    if not mapping_found:
        update_status("WARNING: Could not find 'Account Mapping' to 'FUTURE' mapping section")
    
    update_status(f"Found {len(tag_to_future_tag)} tag to future tag mappings")
    
    # STEP 3: Process the XAV data
    update_status("Processing XAV data...")
    
    processed_data = []
    unmapped_accounts = []
    
    # Filter by selected periods if specified
    for row in xav_data:
        account = row["Nat Account"]
        cc = row["CC"]
        period = row["Period"]
        amount = row["Amount"]
        
        # Skip if this period is not selected (if selection is provided)
        if selected_periods is not None and period not in selected_periods:
            continue
        
        # Check if account mapping exists
        if account not in account_to_tag:
            unmapped_accounts.append({
                'account': account,
                'period': period,
                'cc': cc,
                'amount': amount
            })
            continue  # Skip this row
        
        tag = account_to_tag[account]
        future_tag = tag_to_future_tag.get(tag, tag)  # Use mapped tag or original if not mapped
        month = period_to_month.get(period, period)  # Use mapped month or original if not mapped
        
        processed_data.append({
            'cc': cc,
            'tag': future_tag,
            'period': period,
            'month': month,
            'amount': amount
        })
    
    update_status(f"Processed {len(processed_data)} rows of data")
    
    if unmapped_accounts:
        update_status(f"WARNING: Found {len(unmapped_accounts)} unmapped accounts")
    
    # STEP 4: Aggregate data by CC, tag, and month
    update_status("Aggregating data...")
    
    # Group by CC, tag, and month and sum the amounts
    aggregated_data = {}
    
    for row in processed_data:
        key = (row['cc'], row['tag'], row['month'])
        if key not in aggregated_data:
            aggregated_data[key] = 0
        aggregated_data[key] += row['amount']
    
    # STEP 5: SCAN the FUTURE sheet to understand its structure
    update_status("Scanning FUTURE sheet structure...")
    
    future_sheet = workbook["FUTURE"]
    
    # Scan for CCs in column C (the only fixed structure requirement)
    cc_rows = {}  # Maps CC to its row number
    cc_sections = {}  # Maps CC to its section (start row, end row)
    
    # Look through all rows for numeric values in column C
    for row_num in range(1, future_sheet.max_row + 1):
        cc_value = future_sheet.cell(row=row_num, column=3).value
        
        # Check if the value is a number (could be int or float)
        if cc_value is not None and isinstance(cc_value, (int, float)) and not isinstance(cc_value, str):
            # Look at cells to the right to confirm it's a header row (usually contains month names)
            has_data_to_right = False
            for col_num in range(4, min(future_sheet.max_column + 1, 15)):  # Check up to 10 columns to the right
                if future_sheet.cell(row=row_num, column=col_num).value:
                    has_data_to_right = True
                    break
            
            if has_data_to_right:
                cc_rows[str(int(cc_value))] = row_num
    
    update_status(f"Found {len(cc_rows)} cost centers in FUTURE sheet")
    
    # For each CC, scan for tag rows and months
    future_structure = {}
    future_months = []
    
    for cc, row_num in cc_rows.items():
        # First, find all months in the header row
        month_cols = {}  # Maps month to its column number
        col_num = 4  # Start from column D
        blank_count = 0
        
        while col_num <= future_sheet.max_column and blank_count < 10:
            month_value = future_sheet.cell(row=row_num, column=col_num).value
            
            if month_value is None:
                blank_count += 1
            else:
                blank_count = 0  # Reset blank count when we find a value
                if month_value != "Blabla":  # Skip Blabla columns
                    month_cols[month_value] = col_num
                    if month_value not in future_months:
                        future_months.append(month_value)
            
            col_num += 1
        
        # Now scan rows below this CC for tags
        tag_rows = []  # List of (tag, row_number) tuples
        current_row = row_num + 1
        blank_count = 0
        max_blanks = 3  # Stop after 3 blank rows
        
        while current_row <= future_sheet.max_row and blank_count < max_blanks:
            tag_value = future_sheet.cell(row=current_row, column=3).value
            
            if tag_value is None:
                blank_count += 1
            elif isinstance(tag_value, str):
                # Found a tag row - must be a string and not a number
                if not isinstance(tag_value, (int, float)) and not tag_value.isdigit():
                    tag_rows.append((tag_value, current_row))
                blank_count = 0  # Reset blank counter
            
            current_row += 1
        
        future_structure[cc] = {
            "header_row": row_num,
            "tag_rows": tag_rows,
            "month_cols": month_cols
        }
    
    update_status(f"Found {len(future_months)} months in FUTURE sheet")
    
    # STEP 6: Update the FUTURE sheet based on scanned structure
    update_status("Updating FUTURE sheet with processed data...")
    
    # For each CC section, update the values for each tag and month
    for cc, section in future_structure.items():
        for tag, row_num in section["tag_rows"]:
            # Get the correct future tag if mapped
            for month, col_num in section["month_cols"].items():
                # Look for the aggregated value
                key = (cc, tag, month)
                if key in aggregated_data:
                    value = aggregated_data[key]
                    future_sheet.cell(row=row_num, column=col_num, value=value)
                else:
                    # If no value found, leave as is or clear
                    # future_sheet.cell(row=row_num, column=col_num, value="")
                    pass
    
    # STEP 7: Create or update the LOGS sheet structure
    
    # Ensure "LOGS >>" sheet exists (create if not)
    logs_sheet_name = "LOGS >>"
    if logs_sheet_name not in workbook.sheetnames:
        workbook.create_sheet(logs_sheet_name)
        update_status(f"Created {logs_sheet_name} sheet")
    
    # Create or reset FutureLog sheet after "LOGS >>" sheet
    future_log_name = "FutureLog"
    if future_log_name in workbook.sheetnames:
        # Remove existing sheet
        del workbook[future_log_name]
    
    # Create new FutureLog sheet after LOGS >>
    logs_index = workbook.sheetnames.index(logs_sheet_name)
    future_log = workbook.create_sheet(future_log_name, logs_index + 1)
    
    # Add headers to FutureLog
    log_headers = [
        "Timestamp", 
        "Process Type", 
        "Accounts Processed", 
        "Unmapped Accounts", 
        "CCs Processed", 
        "Months Processed", 
        "Status"
    ]
    
    for col_idx, header in enumerate(log_headers, start=1):
        future_log.cell(row=1, column=col_idx, value=header)
    
    # Add processing summary
    timestamp = datetime.now().isoformat()
    future_log.cell(row=2, column=1, value=timestamp)
    future_log.cell(row=2, column=2, value="XAV to FUTURE")
    future_log.cell(row=2, column=3, value=len(processed_data))
    future_log.cell(row=2, column=4, value=len(unmapped_accounts))
    future_log.cell(row=2, column=5, value=len(cc_rows))
    future_log.cell(row=2, column=6, value=len(future_months))
    future_log.cell(row=2, column=7, value="Success")
    
    update_status(f"Updated {future_log_name} with processing summary")
    
    # STEP 8: Handle unmapped accounts (create processlogFuture if needed)
    if unmapped_accounts:
        update_status("Creating processlogFuture for unmapped accounts...")
        
        # Create processlogFuture sheet
        process_log_name = "processlogFuture"
        log_headers = ["Timestamp", "Account", "Period", "CC", "Amount", "Error"]
        
        if process_log_name in workbook.sheetnames:
            # Remove existing sheet
            del workbook[process_log_name]
        
        # Create new sheet after FutureLog
        logs_index = workbook.sheetnames.index(future_log_name)
        processlogFuture = workbook.create_sheet(process_log_name, logs_index + 1)
        
        # Add headers
        for col_idx, header in enumerate(log_headers, start=1):
            processlogFuture.cell(row=1, column=col_idx, value=header)
        
        # Add unmapped accounts
        for row_idx, item in enumerate(unmapped_accounts, start=2):
            timestamp = datetime.now().isoformat()
            processlogFuture.cell(row=row_idx, column=1, value=timestamp)
            processlogFuture.cell(row=row_idx, column=2, value=item['account'])
            processlogFuture.cell(row=row_idx, column=3, value=item['period'])
            processlogFuture.cell(row=row_idx, column=4, value=item['cc'])
            processlogFuture.cell(row=row_idx, column=5, value=item['amount'])
            processlogFuture.cell(row=row_idx, column=6, value="Account mapping not found")
        
        update_status(f"Created {process_log_name} with {len(unmapped_accounts)} unmapped accounts")
    
    # STEP 9: Save the workbook
    update_status(f"Saving updated workbook to {output_file}...")
    workbook.save(output_file)
    
    update_status("Processing completed successfully!")
    return output_file


class XAVProcessorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("XAV to FUTURE Processor")
        self.root.geometry("700x600")
        self.root.resizable(True, True)
        
        # Create a frame for the file selection
        file_frame = ttk.Frame(root, padding="10")
        file_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # File selection
        ttk.Label(file_frame, text="Select XAV Excel File:").grid(column=0, row=0, sticky=tk.W, pady=5)
        
        self.file_path = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.file_path, width=50).grid(column=0, row=1, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Button(file_frame, text="Browse...", command=self.browse_file).grid(column=1, row=1, padx=5, pady=5)
        
        # Period selection frame (initially hidden)
        self.period_frame = ttk.LabelFrame(root, text="Select Periods to Update", padding="10")
        
        # Variable to hold selected periods
        self.selected_periods = []
        self.period_vars = {}  # Will hold CheckButton variables
        self.scan_done = False
        
        # Add a Scan button
        ttk.Button(file_frame, text="Scan Periods", command=self.scan_periods).grid(column=0, row=2, sticky=tk.W, pady=5)
        
        # Output file options
        output_frame = ttk.Frame(root, padding="10")
        output_frame.pack(fill=tk.X, padx=10, pady=0)
        
        ttk.Label(output_frame, text="Output Options:").grid(column=0, row=0, sticky=tk.W, pady=5)
        
        self.output_same = tk.BooleanVar(value=True)
        ttk.Radiobutton(output_frame, text="Create new file (original filename + ' - Processed')", 
                        variable=self.output_same, value=True).grid(column=0, row=1, sticky=tk.W, pady=2)
        
        ttk.Radiobutton(output_frame, text="Specify output file", 
                        variable=self.output_same, value=False).grid(column=0, row=2, sticky=tk.W, pady=2)
        
        self.output_path = tk.StringVar()
        self.output_entry = ttk.Entry(output_frame, textvariable=self.output_path, width=50, state='disabled')
        self.output_entry.grid(column=0, row=3, sticky=(tk.W, tk.E), pady=5)
        
        self.browse_output_btn = ttk.Button(output_frame, text="Browse...", command=self.browse_output_file, state='disabled')
        self.browse_output_btn.grid(column=1, row=3, padx=5, pady=5)
        
        # Bind change in radio buttons
        self.output_same.trace_add("write", self.toggle_output_entry)
        
        # Create a frame for the process button
        button_frame = ttk.Frame(root, padding="10")
        button_frame.pack(fill=tk.X, padx=10, pady=0)
        
        self.process_btn = ttk.Button(button_frame, text="Process XAV Data", command=self.process_file, state='disabled')
        self.process_btn.pack(pady=10)
        
        # Status frame
        status_frame = ttk.LabelFrame(root, text="Processing Status", padding="10")
        status_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Status text widget
        self.status_text = tk.Text(status_frame, wrap=tk.WORD, width=70, height=15)
        self.status_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(status_frame, orient=tk.VERTICAL, command=self.status_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.status_text.configure(yscrollcommand=scrollbar.set)
        
        # Initial status
        self.update_status("Ready to process XAV data. Please select an Excel file and scan for periods.")
